plugins {
    alias(libs.plugins.android.application)
    id "com.github.ben-manes.versions" version "0.53.0"
}

android {
    namespace = 'org.gzp.shine'
    compileSdk = 34

    defaultConfig {
        applicationId = "org.gzp.shine"
        minSdk = 30
        targetSdk = 33
        versionCode = 1
        versionName = "1.0"
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=c++_shared"
            }
        }
        ndk {
            abiFilters 'arm64-v8a'
        }
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
    externalNativeBuild {
        cmake {
            path = "CMakeLists.txt"
        }
    }
    buildTypes {
        release {
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

            minifyEnabled = true            
            zipAlignEnabled = true
            shrinkResources = true
        }

        debug {
            minifyEnabled = false
            shrinkResources = false            
        }
    }
    
    // Define a flavors for each rust build targets in the client
    def projectFlavors = [
        "game", // the main client - non-example project
        "curve",
        "camera_orbit",
        "camera_follow",
        "camera_free",
        "camera_look_at",
        "input_drivers",
        "input_process",
        "input_gesture",
        "input_multiplayer",
        "pinch_zoom",
        "asset"
    ]
    
    flavorDimensions += "project"
    productFlavors {
        projectFlavors.each { flavorName ->
            "$flavorName" {
                dimension "project"
                applicationIdSuffix ".${flavorName}"
            }
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    buildFeatures {
        viewBinding = true
    }
    packagingOptions {
        // exclude the dummy cpp project, it was required only to include libc++_shared.so
        exclude 'lib/*/libdummy.so'
        
        jniLibs {
            useLegacyPackaging = false
        }       
    }

    sourceSets {
        main {
            assets.srcDirs += files('../../assets')
            res.srcDirs += files('../../assets/android-res')
            jniLibs.srcDirs = ["src/main/jniLibs"]
        }
        
        projectFlavors.each { flavorName ->
            "$flavorName" {
                jniLibs.srcDirs += ["src/main/featureLibs/${flavorName}"]
            }
        }
    }
    
    // Create individual rust build tasks for each flavor
    afterEvaluate {
        projectFlavors.each { flavor ->
            tasks.register("buildRustLib_${flavor}", Exec) {
                group = 'rust'
                description = "Build Rust library for ${flavor} flavor"
                workingDir project.projectDir.parent
                
                def outputDir = "android/src/main/featureLibs/${flavor}"
                def cargoCommand = [
                    'cargo', 'ndk',
                    '-t', 'arm64-v8a',
                    '-o', outputDir,
                    'build',
                    '-p', 'shine-client',
                    '--release',
                    '--lib'
                ]
                
                if (flavor != 'game') {
                    cargoCommand += ['--features', "example_${flavor}"]
                }
                
                commandLine cargoCommand
                
                doFirst {
                    println "Building Rust library for flavor: ${flavor}"
                    println "Running: ${cargoCommand.join(' ')}"
                }
            }
        }
    }
}

// Helper function to determine current flavors from project property or task name
def getCurrentFlavors() {
    def currentFlavors = []
    
    // First check if flavor is specified as project property (-Pflavor=curve or -Pflavor=curve,asset)
    if (project.hasProperty('flavor')) {
        def flavorProperty = project.flavor
        if (flavorProperty.contains(',')) {
            currentFlavors = flavorProperty.split(',').collect { it.trim() }
        } else {
            currentFlavors = [flavorProperty.trim()]
        }
    } else {
        // Fall back to detecting from task name (e.g., assembleCurveDebug -> curve)
        def taskName = gradle.startParameter.taskNames.find { it.contains('assemble') || it.contains('bundle') }
        
        if (taskName) {
            android.productFlavors.each { flavor ->
                if (taskName.toLowerCase().contains(flavor.name.toLowerCase())) {
                    currentFlavors = [flavor.name]
                }
            }
        }
    }

    if (currentFlavors.isEmpty()) {
        currentFlavors = android.productFlavors.collect { it.name }
    }
    
    return currentFlavors
}

// Main task that depends on the relevant flavor subtasks
task buildRustLib {
    group = 'build'
    description = 'Build Rust library for the current flavors'
    
    // Set up dependencies directly based on current flavors
    def currentFlavors = getCurrentFlavors()
    currentFlavors.each { flavor ->
        dependsOn "buildRustLib_${flavor}"
    }
}

dependencies {
    implementation libs.appcompat
    implementation libs.material
    implementation libs.constraintlayout
    testImplementation libs.junit
    androidTestImplementation libs.ext.junit
    androidTestImplementation libs.espresso.core
}

def isNonStable = { String version ->
    def nonStableKeywords = ['ALPHA', 'BETA', 'RC', 'SNAPSHOT', 'M1', 'M2', 'M3', 'M4', 'M5']
    return nonStableKeywords.any { keyword -> version.toUpperCase().contains(keyword) }
}

// Configure tasks based on flavor property
if (project.hasProperty('flavor')) {
    def flavorProperty = project.flavor
    
    // Parse multiple flavors (comma-separated or single flavor)
    def selectedFlavors = []
    if (flavorProperty.contains(',')) {
        selectedFlavors = flavorProperty.split(',').collect { it.trim() }
    } else {
        selectedFlavors = [flavorProperty.trim()]
    }
    
    println "Building only flavors: ${selectedFlavors.join(', ')}"
    
    // Filter variants at the Android level to only include the selected flavors
    android.variantFilter { variant ->
        if (variant.buildType.name == 'release') {
            def flavorName = variant.flavors.first().name
            if (!selectedFlavors.contains(flavorName)) {
                variant.ignore = true
            }
        }
    }
} 

def currentFlavors = getCurrentFlavors()
println "Current flavors: ${currentFlavors.join(', ')}"

// Configure all assemble/bundle tasks to depend on buildRustLib
tasks.matching { task -> 
    task.name.startsWith('assemble') || task.name.startsWith('bundle')
}.configureEach { task ->
    task.dependsOn buildRustLib
}

tasks.named("dependencyUpdates").configure {
    checkForGradleUpdate = true
    checkConstraints = true
    
    rejectVersionIf { candidate ->
        isNonStable(candidate.candidate.version)
    }
}
